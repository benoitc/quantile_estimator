<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
<title>.eunit/quantile_estimator.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /Users/odo/2f/quantile_estimator/.eunit/quantile_estimator.erl by COVER 2013-02-18 at 18:22:49

****************************************************************************

        |  -module(quantile_estimator).
        |  -author('Florian Odronitz &lt;odo@mac.com&gt;').
        |  
        |  % Based on:
        |  % Cormode et. al.:
        |  % "Effective Computation of Biased Quantiles over Data Streams"
        |  
        |  -export([
        |  	new/0,
        |  	insert/3,
        |  	quantile/3,
        |  	compress/2
        |  ]).
        |  
        |  -export([
        |  	f_biased/1,
        |  	f_targeted/1
        |  ]).
        |  
        |  -ifdef(TEST).
        |  -include_lib("eunit/include/eunit.hrl").
        |  -define(DEBUG, true).
        |  -endif.
        |  
        |  -include("quantile_estimator.hrl").
        |  
        |  % -record (group, {v :: number(), g :: number(), delta :: number(), rank :: number()}).
        |  % -record (quantile_estimator, {samples_count :: number(), inserts_since_compression :: number(), data :: [#group{}]})
        |  
        |  -type data_sample() :: number().
        |  -type invariant() :: fun((number(), number()) -&gt; number()).
        |  	
        |  -spec f_biased(number()) -&gt; invariant().
        |  f_biased(Epsilon) -&gt;
     3..|  	fun(Rank, _N) -&gt;
 83029..|  		2 * Epsilon * Rank
        |  	end.
        |  
        |  -spec f_targeted([{number(), number()}]) -&gt; invariant().
        |  f_targeted(Targets) -&gt;
     1..|  	TargetFuns = [f_targeted(Phi, Epsilon)||{Phi, Epsilon} &lt;- Targets],
     1..|  	fun(Rank, N) -&gt;
 49192..|  		lists:min([TargetFun(Rank, N)||TargetFun&lt;-TargetFuns])
        |  	end.
        |  
        |  -spec f_targeted(number(), number()) -&gt; invariant().
        |  f_targeted(Phi, Epsilon) -&gt;
     3..|  	fun(Rank, N) -&gt;
147576..|  		case Phi * N =&lt; Rank of
        |  			true -&gt;
118585..|  				(2 * Epsilon * Rank) / Phi;
        |  			false -&gt;
 28991..|  				(2 * Epsilon * (N - Rank)) / (1 - Phi)
        |  		end
        |  	end.
        |  
        |  -spec new() -&gt; #quantile_estimator{}.
        |  new() -&gt;
     5..|  	#quantile_estimator{samples_count = 0, inserts_since_compression = 0, data_count = 0, data = []}.
        |  
        |  -spec insert(data_sample(), invariant(), #quantile_estimator{}) -&gt; #quantile_estimator{}.
        |  insert(V, Invariant, #quantile_estimator{samples_count = SamplesCount, inserts_since_compression = InsertsSinceCompression, data_count = DataCount, data = Data}) -&gt;
  5007..|  	#quantile_estimator{
        |  		samples_count = SamplesCount + 1,
        |  		inserts_since_compression = InsertsSinceCompression + 1,
        |  		data_count = DataCount + 1,
        |  		data = insert(V, Data, SamplesCount, Invariant, 0)
        |  	}.
        |  
        |  % we terminate and the group has been added
        |  insert(undefined, [], _N, _Invariant, _Rank) -&gt;
  4982..|  	[];
        |  
        |  % we terminate but the group has not been added yet
        |  % so this is the maximum value
        |  insert(V, [], _, _, RankLast) -&gt;
    25..|  	[#group{v = V, g = 1, delta = 0, rank = RankLast + 1}];
        |  
        |  % the group has already been inserted, just append
        |  % and increase the rank by 1
        |  insert(undefined, [Next = #group{rank = RankNext}|DataTail], N, _, undefined) -&gt;
2239757.|  	NextUpdated = Next#group{rank = RankNext + 1},
2239757.|  	[NextUpdated|insert(undefined, DataTail, N, undefiend, undefined)];
        |  
        |  % the group has not yet been insterted
        |  % insert it and continue
        |  insert(V, [Next = #group{v = Vi, g = Gi, rank = RankNext}|DataTail], N, Invariant, RankLast) -&gt;
2257758.|  	Ranki = RankLast + Gi,
        |  	% did we pass a smaller Vi?
2257758.|  	case Vi &gt;= V of
        |  		true -&gt;
  4982..|  			GroupNew = 
        |  			case Ranki =:= 1 of
    20..|  				true  -&gt; #group{v = V, g = 1, delta = 0, rank = RankLast + 1};
  4962..|  				false -&gt; #group{v = V, g = 1, delta = clamp(floor(Invariant(Ranki, N)) - 1), rank = RankLast +1}
        |  			end,
  4982..|  			[GroupNew|[Next#group{rank = RankNext + 1}|insert(undefined, DataTail, N, undefiend, undefined)]];
        |  		false -&gt;
2252776.|  			[Next|insert(V, DataTail, N, Invariant, Ranki)]
        |  	end.
        |  
        |  -spec compress(invariant(), #quantile_estimator{}) -&gt; #quantile_estimator{}.
        |  compress(Invariant, #quantile_estimator{samples_count = N, data = Data}) -&gt;
    15..|  	DataCompressed = lists:reverse(compress(Invariant, N, lists:reverse(Data), undefined)),
    15..|  	#quantile_estimator{
        |  		samples_count = N,
        |  		inserts_since_compression = 0,
        |  		data_count = length(DataCompressed),
        |  		data = DataCompressed
        |  	}.
        |  
        |  % This is the first call that just splits off one group as a merge candidate
        |  compress(Invariant, N, [Next | Rest], undefined)-&gt;
  3572..|  	compress(Invariant, N, Rest, Next);
        |  
        |  % only one group is left
        |  compress(_, _, [], Last) -&gt;
     3..|  	[Last];
        |  
        |  % we never merge the two last groups since the edge groups need to be untouched
        |  compress(_, _, [Next], Last) -&gt;
    12..|  	[Last|[Next]];
        |  
        |  compress(Invariant, N, [Next = #group{g = Gi, rank = Ranki} | Rest], Last = #group{g = Giplusone, delta = Deltaiplusone}) -&gt;
        |  	% 		error_logger:info_msg("Rank:~p\n", [Ranki]),
        |  	% error_logger:info_msg("comress ~p =&lt; ~p \n", [(Gi + Giplusone + Deltaiplusone), Invariant(Ranki, N)]),
        |  	% 		error_logger:info_msg("Last:~p\n", [Last]),
  5930..|  	case Gi + Giplusone + Deltaiplusone =&lt; Invariant(Ranki, N) of
        |  		true -&gt;
        |  			% [Last|[Next|compress(Invariant, N, Rest, Ranki + Gi, undefined)]];
  3557..|  			[merge(Last, Next)|compress(Invariant, N, Rest, undefined)];
        |  		false -&gt;
  2373..|  			[Last|compress(Invariant, N, Rest, Next)]
        |  	end.
        |  
        |  merge(#group{g = Giplusone, v = Viplusone, delta = Deltaiplusone, rank = Rankiplusone}, #group{g = Gi, rank = Ranki}) -&gt;
  3557..|  	C = Rankiplusone &gt; Ranki,
        |  	% error_logger:info_msg("{Rankiplusone, Ranki, C}: ~p\n", [{Rankiplusone, Ranki, C}]),
  3557..|  	C = true,
        |  	% error_logger:info_msg("merging...GI:~p , Giplusone:~p\n", [Gi, Giplusone]),
  3557..|  	#group{v = Viplusone, g = Gi + Giplusone, delta = Deltaiplusone, rank = Ranki}.
        |  
        |  -spec quantile(number(), invariant(), #quantile_estimator{}) -&gt; number().
        |  quantile(_, _, #quantile_estimator{data = []}) -&gt;
<font color=red>     0..|  	throw({error, empty_stats});</font>
        |  
        |  quantile(Phi, Invariant, #quantile_estimator{samples_count = N, data = [First|DataStructure]}) -&gt;
   381..|  	quantile(Phi, Invariant, DataStructure, N, 0, First).
        |  
        |  quantile(_, _, [], _, _, #group{v = Vlast}) -&gt;
    12..|  	Vlast;
        |  
        |  quantile(Phi, Invariant, [Next = #group{g = Gi, delta = Deltai}|DataStructure], N, Rank, #group{v = Vlast}) -&gt;
121203..|  	case (Rank + Gi + Deltai) &gt; (Phi * N + Invariant(Phi * N, N) / 2) of
        |  		true -&gt;
   369..|  			Vlast;
        |  		false -&gt;
120834..|  			quantile(Phi, Invariant, DataStructure, N, Rank + Gi, Next)
        |  	end.
        |  
        |  floor(X) -&gt;
  4962..|      T = erlang:trunc(X),
  4962..|      case (X - T) of
<font color=red>     0..|          Neg when Neg &lt; 0 -&gt; T - 1;</font>
  4804..|          Pos when Pos &gt; 0 -&gt; T;
   158..|          _ -&gt; T
        |      end.
        |  
  3844..|  clamp(X) when X &gt;= 0 -&gt; X;
  1118..|  clamp(X) when X &lt; 0 -&gt; 0.
        |  
        |  
        |  -ifdef(TEST).
        |  
        |  quantile_estimator_test_() -&gt;
     2..|  [{foreach, local,
        |  	fun test_setup/0,
        |  	fun test_teardown/1,
        |  	[
        |  		{"simple insert", fun test_insert/0}
        |  		,{"quantiles are working", fun test_quantile/0}
        |  		,{"quantiles are working with compression and biased quantiles", fun test_compression_biased/0}
        |  		,{"quantiles are working with compression and targeted quantiles", fun test_comression_targeted/0}
        |  		% ,{"quantiles are working with long tail data set", timeout, 1000, fun test_long_tail/0}
        |  	]}
        |  ].
        |  
     4..|  test_setup() -&gt; nothing.
     4..|  test_teardown(_) -&gt; nothing.
        |  
        |  qe(SamplesCount, Data) -&gt;
     6..|  	qe(SamplesCount, SamplesCount, Data).
        |  
        |  qe(SamplesCount, InsertsSinceCompression, Data) -&gt;
     6..|  	#quantile_estimator{
        |  		samples_count = SamplesCount,
        |  		inserts_since_compression = InsertsSinceCompression,
        |  		data_count = length(Data),
        |  		data = Data
        |  	}.
        |  
        |  test_insert() -&gt;
     1..|  	Invariant = f_biased(0.001),
     1..|  	Insert = fun(Value, Data) -&gt; insert(Value, Invariant, Data) end,
     1..|  	QE1 = Insert(13, quantile_estimator:new()),
     1..|  	?assertEqual(
        |  		qe(1, [#group{v = 13, g = 1, delta = 0, rank = 1}]),
     1..|  	QE1),
     1..|  	QE2 = Insert(2, QE1),
     1..|  	?assertEqual(
        |  		qe(2,
        |  			[
        |  			#group{v = 2,  g = 1, delta = 0, rank = 1},
        |  			#group{v = 13, g = 1, delta = 0, rank = 2}
        |  			]
        |  		),
     1..|  	QE2),
     1..|  	QE3 = Insert(8, QE2),
     1..|  	?assertEqual(
        |  		qe(3,
        |  			[
        |  			#group{v = 2,  g = 1, delta = 0, rank = 1},
        |  			#group{v = 8,  g = 1, delta = 0, rank = 2},
        |  			#group{v = 13, g = 1, delta = 0, rank = 3}
        |  			]
        |  		),
     1..|  	QE3),
     1..|  	QE4 = Insert(-3, QE3),
     1..|  	?assertEqual(
        |  		qe(4,
        |  			[
        |  			#group{v = -3, g = 1, delta = 0, rank = 1},
        |  			#group{v = 2,  g = 1, delta = 0, rank = 2},
        |  			#group{v = 8,  g = 1, delta = 0, rank = 3},
        |  			#group{v = 13, g = 1, delta = 0, rank = 4}
        |  			]
        |  		),
     1..|  	QE4),
     1..|  	QE5 = Insert(99, QE4),
     1..|  	?assertEqual(
        |  		qe(5,
        |  			[
        |  			#group{v = -3, g = 1, delta = 0, rank = 1},
        |  			#group{v = 2,  g = 1, delta = 0, rank = 2},
        |  			#group{v = 8,  g = 1, delta = 0, rank = 3},
        |  			#group{v = 13, g = 1, delta = 0, rank = 4},
        |  			#group{v = 99, g = 1, delta = 0, rank = 5}
        |  			]
        |  		),
     1..|  	QE5),
     1..|  	QE6 = Insert(14, QE5),
     1..|  	?assertEqual(
        |  		qe(6,
        |  			[
        |  			#group{v = -3, g = 1, delta = 0, rank = 1},
        |  			#group{v = 2,  g = 1, delta = 0, rank = 2},
        |  			#group{v = 8,  g = 1, delta = 0, rank = 3},
        |  			#group{v = 13, g = 1, delta = 0, rank = 4},
        |  			#group{v = 14, g = 1, delta = 0, rank = 5},
        |  			#group{v = 99, g = 1, delta = 0, rank = 6}
        |  			]
        |  		),
     1..|  	QE6).
        |  
        |  test_quantile() -&gt;
        |  	% we create a set of 1000 random values and test if the guarantees are met
     1..|  	Invariant = f_biased(0.001),
     1..|  	N = 1000,
     1..|  	Samples = [random:uniform()||_ &lt;- lists:seq(1, N)],
     1..|  	Data = lists:foldl(fun(Sample, Stats) -&gt; insert(Sample, Invariant, Stats) end, quantile_estimator:new(), Samples),
        |  	% error_logger:info_msg("D:~p\n", [D]),
     1..|  	validate(Samples, Invariant, Data),
     1..|  	Samples2 = [5],
     1..|  	Data2 = lists:foldl(fun(Sample, Stats) -&gt; insert(Sample, Invariant, Stats) end, quantile_estimator:new(), Samples2),
     1..|  	?assertEqual(5, quantile(0, Invariant, Data2)),
     1..|  	?assertEqual(5, quantile(1, Invariant, Data2)),
     1..|  	?assertEqual(5, quantile(0.99, Invariant, Data2)).
        |  
        |  	
        |  test_compression_biased() -&gt;
        |  	% we create a set of 1000 random values and test if the guarantees are met
     1..|  	Invariant = f_biased(0.01),
     1..|  	N = 2000,
     1..|  	Samples = [random:uniform()||_ &lt;- lists:seq(1, N)],
     1..|  	Data = lists:foldl(fun(Sample, Stats) -&gt; insert(Sample, Invariant, Stats) end, quantile_estimator:new(), Samples),
     1..|  	DL = Data#quantile_estimator.data,
     1..|  	validate(Samples, Invariant, Data),
     1..|  	compress_and_validate(Samples, Invariant, Data, length(DL)).
        |  
        |  test_comression_targeted() -&gt;
        |  	% we create a set of 1000 random values and test if the guarantees are met
     1..|  	Invariant = quantile_estimator:f_targeted([{0.05, 0.005}, {0.5, 0.02}, {0.95, 0.005}]),
     1..|  	N = 2000,
     1..|  	Samples = [random:uniform()||_ &lt;- lists:seq(1, N)],
     1..|  	Data = lists:foldl(fun(Sample, Stats) -&gt; insert(Sample, Invariant, Stats) end, quantile_estimator:new(), Samples),
     1..|  	DL = Data#quantile_estimator.data,
     1..|  	validate(Samples, Invariant, Data),
     1..|  	compress_and_validate(Samples, Invariant, Data, length(DL)).
        |  
        |  test_long_tail() -&gt;
<font color=red>     0..|  	{ok, [Samples]} = file:consult(os:getenv("TESTDIR") ++ "us_city_populations"),</font>
<font color=red>     0..|  	Invariant = quantile_estimator:f_targeted([{0.01, 0.005}, {0.05, 0.005}, {0.5, 0.025}, {0.95, 0.005}, {0.99, 0.005}]),</font>
        |  	% Invariant = quantile_estimator:f_biased(0.001),
<font color=red>     0..|  	lists:foldl(</font>
        |  		fun(Sample, {Stats = #quantile_estimator{data = DL}, SamplesUsed}) -&gt;
        |  			% error_logger:info_msg("Stats:~p\n", [Stats]),
<font color=red>     0..|  			StatsNew = insert(Sample, Invariant, Stats),</font>
<font color=red>     0..|  			SamplesNew = [Sample|SamplesUsed],</font>
        |  			% error_logger:info_msg("StatsNew:~p\n", [StatsNew]),
<font color=red>     0..|  			validate(SamplesNew, Invariant, StatsNew),</font>
<font color=red>     0..|  			StatsCompressed =</font>
        |  			case length(SamplesUsed) rem 10 =:= 0 of
        |  				true -&gt;
<font color=red>     0..|  					compress_and_validate(SamplesNew, Invariant, StatsNew, length(DL));</font>
        |  					% StatsNew;
        |  				false -&gt;
<font color=red>     0..|  					StatsNew</font>
        |  			end,
<font color=red>     0..|  			{StatsCompressed, SamplesNew}</font>
        |  		end,
        |  		{quantile_estimator:new(), []},
        |  		Samples
        |  	).
        |  
        |  validate(Samples, Invariant, Estimate = #quantile_estimator{samples_count = N, data = Series}) -&gt;
    18..|  	Index = fun(Element, List) -&gt; length(lists:takewhile(fun(E) -&gt; E &lt; Element end, List)) end,
    18..|  	SamplesSort = lists:sort(Samples),
    18..|  	validate_ranks(Series, 0),
    18..|  	Quantiles = [0.01, 0.05, 0.10, 0.5, 0.90, 0.95, 0.99],
    18..|  	RankestRankrealDevDevallowed = [
   126..|  		{
        |  			Index(quantile:quantile(Q, SamplesSort), SamplesSort), 
        |  			Index(quantile(Q, Invariant, Estimate), SamplesSort), 
        |  			abs(Index(quantile:quantile(Q, SamplesSort), SamplesSort) - Index(quantile(Q, Invariant, Estimate), SamplesSort)),
        |  			quantile:ceil(Invariant(Index(quantile(Q, Invariant, Estimate), SamplesSort), N))
    18..|  		} || Q &lt;- Quantiles],
        |  	% [error_logger:info_msg("QReal:~p,~p,~p\n", [Q, N, quantile:quantile(Q, SamplesSort)]) || Q &lt;- [0.0, 1.0]],
        |  	% [error_logger:info_msg("QEst:~p,~p,~p\n", [Q, N, quantile(Q, Invariant, Estimate)]) || Q &lt;- [0.0, 1.0]],
        |  	% [error_logger:info_msg("QReal:~p,~p,~p\n", [Q, N, quantile:quantile(Q, SamplesSort)]) || Q &lt;- Quantiles],
        |  	% [error_logger:info_msg("QEst:~p,~p,~p\n", [Q, N, quantile(Q, Invariant, Estimate)]) || Q &lt;- Quantiles],
        |  	% error_logger:info_msg("N:~p, RankestRankrealDevDevallowed:~p\n", [N, RankestRankrealDevDevallowed]),
    18..|  	[?assertEqual(true, (Dev =&lt; DevAlloweddev)) || {_, _, Dev, DevAlloweddev} &lt;- RankestRankrealDevDevallowed].
        |  			
        |  validate_ranks([_], _) -&gt;
    18..|  	undefined;
        |  
        |  validate_ranks([#group{rank = Rank}|Rest], RankLast)	-&gt;
 10939..|  	?assert(Rank &gt; RankLast),
 10939..|  	validate_ranks(Rest, Rank).
        |  % validate(Samples, Invariant, Data = {N, _}) -&gt;
        |  % 	SamplesSort = lists:sort(Samples),
        |  % 	RankEstimate = [{R, quantile((R-1)/N, Invariant, Data)}||R&lt;-[1, N*0.01, N*0.05, N*0.10, N*0.5, N*0.90, N*0.95, N*0.99, N]],
        |  % 	RankEstimateRank = [{Rank, string:str(SamplesSort, [Estimate])}||{Rank, Estimate} &lt;- RankEstimate],
        |  % 	error_logger:info_msg("N:~p\n", [N]),
        |  % 	error_logger:info_msg("RankEstimateRank:~p\n", [RankEstimateRank]),
        |  % 	DeviationAllowedDeviation = [{abs(Rank - EstimateRank), Invariant(Rank, N)} || {Rank, EstimateRank} &lt;- RankEstimateRank],
        |  % 	error_logger:info_msg("DeviationAllowedDeviation:~p\n", [DeviationAllowedDeviation]),
        |  % 	[?assert(Deviation =&lt; AllowedDeviation)||{Deviation, AllowedDeviation} &lt;- DeviationAllowedDeviation].
        |  
        |  compress_and_validate(Samples, Invariant, Est, SizeLast) -&gt;
        |  	% error_logger:info_msg("before compress {N, Data}: ~p\n", [Data]),
    15..|  	EstCompressed = compress(Invariant, Est),
        |  	% error_logger:info_msg("DataCompressed: ~p\n", [DataCompressed]),
    15..|  	?assertEqual(Est#quantile_estimator.samples_count, EstCompressed#quantile_estimator.samples_count),
    15..|  	?assertEqual(0, EstCompressed#quantile_estimator.inserts_since_compression),
        |  	% error_logger:info_msg("-------&gt;reduced from :~p to: ~p\n", [length(List), length(ListCompressed)]),
        |  	% error_logger:info_msg("ratio: ~p,~p\n", [N, length(ListCompressed)]),
    15..|  	?assert(length(EstCompressed#quantile_estimator.data) =&lt; length(Est#quantile_estimator.data)),
    15..|  	?assertEqual(length(EstCompressed#quantile_estimator.data), EstCompressed#quantile_estimator.data_count),
        |  	% error_logger:info_msg("DataCompressed:~p\n", [DataCompressed]),
    15..|  	validate(Samples, Invariant, EstCompressed),
    15..|  	case length(EstCompressed#quantile_estimator.data) &lt; SizeLast of
        |  		true -&gt;
    13..|  			compress_and_validate(Samples, Invariant, EstCompressed, length(EstCompressed#quantile_estimator.data));
        |  		false -&gt;
     2..|  			EstCompressed
        |  	end.
        |  
        |  -endif.
        |  
</pre>
</body>
</html>
